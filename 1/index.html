<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 1: Images of the Russian Empire</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Project 1: Images of the Russian Empire</h1>
            <p class="subtitle">Colorizing the Prokudin-Gorskii photo collection</p>
            <p class="subtitle">Due: September 12, 2025 • CS180</p>
        </header>
        
        <div style="padding: 20px;">
            <a href="../index.html">← Back to Portfolio</a>
        </div>

        <main>
            <!-- Overview Section -->
            <div class="project-content">
                <h2>Overview</h2>
                <div class="project-content-body">
                    <p>The project entails aligning three color channel images to form a single RGB color image.</p>
                    
                    <h3>Implementation Details</h3>
                    
                    <h4>Single-Scale Implementation</h4>
                    <p>For the simple alignment, my approach is to follow a moving window. First, I remove 50 pixels from all sides of the image to remove the border. This is because there are parts of the border that have imperfections that might interfere with how the border is aligned. 50 was a good balance between removing the interfering parts while still maintaining the important information.</p>

                    <p>From there, I create a window with the center at (0,0). The top right corner is (window_min, window_min), and the bottom left corner is (window_max, window_max). These are all of the offset starting positions that I will be starting from. Window_min is negative, and window_max is positive.</p>

                    <div class="image-gallery" style="margin: 20px 0;">
                        <div class="image-container" style="max-width: 500px; margin: 0 auto;">
                            <img src="./implementation_imgs/window.jpeg" alt="Implementation diagram: window" onerror="this.style.display='none'">
                            <div class="image-caption">window</div>
                        </div>
                    </div>

                    <p>I treat the base slide (blue in my diagram) as being anchored in place, and align the top right corner of the base slide with the center of the window, at (0,0).</p>

                    <div class="image-gallery" style="margin: 20px 0;">
                        <div class="image-container" style="max-width: 500px; margin: 0 auto;">
                            <img src="./implementation_imgs/base_slide.jpeg" alt="Implementation diagram: base slide" onerror="this.style.display='none'">
                            <div class="image-caption">base slide</div>
                        </div>
                    </div>

                    <p>From there, I have the moving slide (red) align its top right corner with each coordinate within the window.</p>

                    <div class="image-gallery" style="margin: 20px 0;">
                        <div class="image-container" style="max-width: 500px; margin: 0 auto;">
                            <img src="./implementation_imgs/moving%20alignments.jpeg" alt="Implementation diagram: moving alignments" onerror="this.style.display='none'">
                            <div class="image-caption">moving alignments</div>
                        </div>
                    </div>

                    <div class="image-gallery" style="margin: 20px 0;">
                        <div class="image-container" style="max-width: 500px; margin: 0 auto;">
                            <img src="./implementation_imgs/moving_path.jpeg" alt="Implementation diagram: moving path" onerror="this.style.display='none'">
                            <div class="image-caption">moving path</div>
                        </div>
                    </div>

                    <p>I crop both slides to just include the part that overlaps between the offset moving slide and the stationary base slide.</p>

                    <div class="image-gallery" style="margin: 20px 0;">
                        <div class="image-container" style="max-width: 500px; margin: 0 auto;">
                            <img src="./implementation_imgs/offsets.jpeg" alt="Implementation diagram: offsets" onerror="this.style.display='none'">
                            <div class="image-caption">offsets</div>
                        </div>
                    </div>

                    <p><strong>Offset calculations:</strong></p>
                    <p>When offset_x < 0: base_left = 0, base_right = img_width + offset_x, moving_left = -offset_x, moving_right = img_width</p>
                    <p>When offset_x > 0: base_left = offset_x, base_right = img_width, moving_left = 0, moving_right = img_width - offset_x</p>

                    <div class="image-gallery" style="margin: 20px 0;">
                        <div class="image-container" style="max-width: 500px; margin: 0 auto;">
                            <img src="./implementation_imgs/negative%20offset.jpeg" alt="Implementation diagram: negative offset" onerror="this.style.display='none'">
                            <div class="image-caption">negative offset</div>
                        </div>
                    </div>

                    <p>When offset_y < 0: base_top = 0, base_bottom = img_height + offset_y, moving_top = -offset_y, moving_bottom = img_height</p>
                    <p>When offset_y > 0: base_top = offset_y, base_bottom = img_height, moving_top = 0, moving_bottom = img_height - offset_y</p>

                    <div class="image-gallery" style="margin: 20px 0;">
                        <div class="image-container" style="max-width: 500px; margin: 0 auto;">
                            <img src="./implementation_imgs/positive_offset.jpeg" alt="Implementation diagram: positive offset" onerror="this.style.display='none'">
                            <div class="image-caption">positive offset</div>
                        </div>
                    </div>

                    <p>For each set of cropped slides, I compute the normalized cross correlation. I do this by flattening both slides, centering them at 0 by subtracting their mean, and normalize them by dividing by their norm. I then return the dot product between the two slides. This is the distance.</p>

                    <div class="image-gallery" style="margin: 20px 0;">
                        <div class="image-container" style="max-width: 500px; margin: 0 auto;">
                            <img src="./implementation_imgs/NCC.jpeg" alt="Implementation diagram: NCC" onerror="this.style.display='none'">
                            <div class="image-caption">NCC</div>
                        </div>
                    </div>

                    <p>My end result is to return the offset_x and offset_y pair (referring to the difference in coordinates between the top right corner of the base slide and the top right corner of the moving slide) that corresponds to the highest NCC.</p>

                    <p>Originally, I was trying to both roll and crop my images, which was causing issues where I was moving the images too many times and actually harming the final result. It really helped to create a dummy problem which was just an np array with a singular white square in the middle, and getting to see how my approach responded.</p>

                    <h4>Multi-Scale Pyramid</h4>
                    <p>For the pyramid alignment, I called the simple alignment multiple times, with different resolutions of the image. For each level (starting from the lowest resolution/highest level), I shrunk the resolution of the image by scale_factor = 0.5**level. I then removed 45 * scale_factor pixels from each side of the image to remove the border. Then, I created the window, but instead of centering the window at (0,0), I instead centered the window at the previous best offset that I had found, scaled to match the level (I multiply the previous best offset by scale_factor = 0.5**level). Then, I ran an exhaustive search with this window to get the best offset for this level. I then scale that offset in a reverse manner back to the size of the original image, and then continue on to the next level.</p>

                    <div class="image-gallery" style="margin: 20px 0;">
                        <div class="image-container" style="max-width: 500px; margin: 0 auto;">
                            <img src="./implementation_imgs/pyramid_process.jpeg" alt="Implementation diagram: pyramid process" onerror="this.style.display='none'">
                            <div class="image-caption">pyramid process</div>
                        </div>
                    </div>

                    <p>I originally had the ratio of levels to window size wrong: I had a larger window size and less levels. While this did result in the images successfully being aligned, this caused the runtime to be extremely long. I reduced the window size by a factor of 5 for each dimension and added two extra levels, and I received the same results of the quality of my alignment but had a significantly lower (over two times) runtime. This makes sense, because instead of testing 225 possible alignments across 4 levels, I am now testing 9 possible alignments across 6 levels. For self_portrait.tif, I think that the images don't have the same brightness values, which makes it more difficult to align. I think that this may be able to be resolved using edge alignment.</p>
                </div>
            </div>

            <!-- Results Section -->
            <div class="project-content">
                <h2>Results on Example Images</h2>
                <div class="project-content-body">
                    <p>Below are the results of my alignment algorithm on the provided example images. The displacement vectors show the (x,y) offsets used to align the Green and Red channels to the Blue channel.</p>

                    <!-- Low-res JPEG Images -->
                    <h3>Low-Resolution Images (.jpg)</h3>
                    <div id="jpeg-results"></div>

                    <!-- High-res TIFF Images -->
                    <h3>High-Resolution Images (.tif)</h3>
                    <div id="tiff-results"></div>

                    <!-- Complete Alignment Results Table -->
                    <h3>Complete Alignment Results</h3>
                    <div style="overflow-x: auto;">
                        <table id="results-table" style="margin: 20px auto; border-collapse: collapse; border: 1px solid #ddd; min-width: 600px;">
                            <thead style="background-color: #f2f2f2;">
                                <tr>
                                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Image</th>
                                    <th style="border: 1px solid #ddd; padding: 12px; text-align: center;">Green Offset (x, y)</th>
                                    <th style="border: 1px solid #ddd; padding: 12px; text-align: center;">Red Offset (x, y)</th>
                                </tr>
                            </thead>
                            <tbody id="table-body">
                                <!-- Results will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Additional Images Section -->
            <div class="project-content">
                <h2>Additional Images from the Prokudin-Gorskii Collection</h2>
                <div class="project-content-body">
                    <p>I selected additional images from the Prokudin-Gorskii collection to test my algorithm on different types of scenes and content.</p>
                    <div id="my-images-container">
                        <!-- Additional images will be loaded automatically -->
                    </div>
                </div>
            </div>
        </main>

        <footer>
            <p>&copy; 2025 CS180 Portfolio • Sylvie Venuto • UC Berkeley</p>
        </footer>
    </div>

    <script>
        // Function to load and parse CSV data
        async function loadAlignmentResults() {
            try {
                const response = await fetch('./alignment_results.csv');
                const csvText = await response.text();
                
                // Simple CSV parser
                const lines = csvText.trim().split('\n');
                const headers = lines[0].split(',');
                const results = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    const result = {};
                    headers.forEach((header, index) => {
                        result[header.trim()] = values[index] ? values[index].trim() : '';
                    });
                    results.push(result);
                }
                
                return results;
            } catch (error) {
                console.error('Error loading CSV:', error);
                return [];
            }
        }

        // Function to load and parse CSV data for additional images
        async function loadMyImagesResults() {
            try {
                const response = await fetch('./my_images_alignment_results.csv');
                const csvText = await response.text();
                
                const lines = csvText.trim().split('\n');
                const headers = lines[0].split(',');
                const results = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    const result = {};
                    headers.forEach((header, index) => {
                        result[header.trim()] = values[index] ? values[index].trim() : '';
                    });
                    results.push(result);
                }
                
                return results;
            } catch (error) {
                console.error('Error loading my images CSV:', error);
                return [];
            }
        }

        // Function to create image display section
        function createImageSection(imageName, greenOffset, redOffset) {
            const baseImageName = imageName.replace('.tif', '').replace('.jpg', '');
            
            return `
                <h4>${imageName}</h4>
                <div class="image-gallery">
                    <div class="image-container" style="max-width: 400px; margin: 0 auto;">
                        <img src="./aligned_images/aligned_${baseImageName}.jpg" alt="Aligned ${baseImageName} image">
                        <div class="image-caption">
                            Aligned Result<br>
                            Green offset: (${greenOffset})<br>
                            Red offset: (${redOffset})
                        </div>
                    </div>
                </div>
            `;
        }

        // Function to create additional image section (same format as main images)
        function createMyImageSection(imageName, greenOffset, redOffset) {
            const baseImageName = imageName.replace('aligned_', '').replace('.jpg', '');
            
            return `
                <h4>${baseImageName}.jpg</h4>
                <div class="image-gallery">
                    <div class="image-container" style="max-width: 400px; margin: 0 auto;">
                        <img src="./my_images_aligned/${imageName}" alt="Additional image: ${baseImageName}">
                        <div class="image-caption">
                            Aligned Result<br>
                            Green offset: (${greenOffset})<br>
                            Red offset: (${redOffset})
                        </div>
                    </div>
                </div>
            `;
        }

        // Function to populate results
        async function populateResults() {
            const results = await loadAlignmentResults();
            
            if (results.length === 0) {
                console.error('No results loaded');
                return;
            }

            const jpegContainer = document.getElementById('jpeg-results');
            const tiffContainer = document.getElementById('tiff-results');
            const tableBody = document.getElementById('table-body');
            
            let jpegHtml = '';
            let tiffHtml = '';
            let tableHtml = '';

            results.forEach(result => {
                const imageName = result.image_name;
                const greenOffset = `${result.best_w_g}, ${result.best_h_g}`;
                const redOffset = `${result.best_w_r}, ${result.best_h_r}`;
                
                // Create image section
                const imageSection = createImageSection(imageName, greenOffset, redOffset);
                
                // Separate by file type
                if (imageName.endsWith('.jpg')) {
                    jpegHtml += imageSection;
                } else if (imageName.endsWith('.tif')) {
                    tiffHtml += imageSection;
                }
                
                // Add to table
                tableHtml += `
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 12px;">${imageName}</td>
                        <td style="border: 1px solid #ddd; padding: 12px; text-align: center;">(${greenOffset})</td>
                        <td style="border: 1px solid #ddd; padding: 12px; text-align: center;">(${redOffset})</td>
                    </tr>
                `;
            });

            // Populate the sections
            jpegContainer.innerHTML = jpegHtml;
            tiffContainer.innerHTML = tiffHtml;
            tableBody.innerHTML = tableHtml;
            
            // Load and populate additional images with their results
            const myImagesResults = await loadMyImagesResults();
            const myImagesContainer = document.getElementById('my-images-container');
            
            if (myImagesResults.length > 0) {
                let myImagesHtml = '';
                myImagesResults.forEach(result => {
                    const imageName = result.image_name;
                    const greenOffset = `${result.best_w_g}, ${result.best_h_g}`;
                    const redOffset = `${result.best_w_r}, ${result.best_h_r}`;
                    
                    // Convert image name to aligned filename
                    const baseImageName = imageName.replace('.tif', '').replace('.jpg', '');
                    const alignedFileName = `aligned_${baseImageName}.jpg`;
                    
                    myImagesHtml += createMyImageSection(alignedFileName, greenOffset, redOffset);
                });
                myImagesContainer.innerHTML = myImagesHtml;
            } else {
                myImagesContainer.innerHTML = '<p>No additional images found.</p>';
            }
        }

        // Load results when page loads
        document.addEventListener('DOMContentLoaded', populateResults);
    </script>
</body>
</html>
